<!DOCTYPE html>
<html lang="vi">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Tr√¨nh t·∫°o s∆° ƒë·ªì PERT</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="stylesheet" href="https://unpkg.com/tippy.js@6/dist/tippy.css" />
    <script src="https://unpkg.com/@popperjs/core@2"></script>
    <script src="https://unpkg.com/tippy.js@6"></script>
    <style>
      /* Ki·ªÉu d√°ng b·ªï sung */
      body {
        font-family: "Inter", sans-serif;
        user-select: none;
        -webkit-user-select: none;
        -moz-user-select: none;
        -ms-user-select: none;
      }
      input::placeholder {
        text-align: center;
      }
      .action-button {
        @apply px-2 py-1 text-xs bg-gray-200 hover:bg-gray-300 rounded transition-colors duration-150;
      }
      .load-button {
        @apply px-3 py-1 text-xs bg-indigo-100 hover:bg-indigo-200 text-indigo-700 rounded transition-colors duration-150 mr-2;
      }
      #pertChart svg {
        width: 100%;
        height: auto;
        min-height: 500px;
        border: 1px solid #ccc;
        background-color: #f9f9f9;
        border-radius: 8px;
        cursor: grab;
      }
      #pertChart svg.grabbing {
        cursor: grabbing;
      }
      /* Node styles */
      .node {
        cursor: grab;
      }
      .node.dragging {
        cursor: grabbing;
      }
      .node circle {
        stroke: #333;
        stroke-width: 1.5;
        fill: #fff;
        filter: drop-shadow(2px 2px 2px rgba(0, 0, 0, 0.1));
      }
      .node line.divider {
        stroke: #aaa;
        stroke-width: 1;
      }
      /* Node text styles */
      .node text {
        font-size: 10px;
        font-weight: bold;
        text-anchor: middle;
        dominant-baseline: central;
        pointer-events: none;
        cursor: help; /* Add help cursor to text elements */
      }
      .node text.node-id {
        fill: #555;
      }
      .node text.es-text {
        fill: red;
      }
      .node text.lf-text {
        fill: blue;
      }
      .node text.slack-text {
        fill: purple;
      }
      /* Edge styles */
      .edge path {
        stroke: #666;
        stroke-width: 1.5;
        fill: none;
      }
      /* Edge text background */
      .edge text {
        font-size: 10px;
        text-anchor: middle;
        fill: #333;
        pointer-events: none;
        paint-order: stroke;
        stroke: #f9f9f9;
        stroke-width: 3px;
        stroke-linejoin: round;
        cursor: help; /* Add help cursor to edge text */
      }
      /* Critical path styles */
      .edge.critical path {
        stroke: orange;
        stroke-width: 2.5;
      }
      .edge.critical text {
        fill: orange;
        font-weight: bold;
        stroke: #f9f9f9;
      }
      .node.critical circle {
        stroke: orange;
        stroke-width: 2.5;
      }
      .node.critical line.divider {
        stroke: orange;
      }
      /* Markers */
      marker#arrowhead {
        fill: #666;
      }
      marker#arrowhead-critical {
        fill: orange;
      }
      /* Hide error message div initially */
      #errorMessage:empty {
        display: none;
      }
      /* Remove default title style, Tippy handles it */
      /*
      [title] {
         cursor: help;
         text-decoration: underline dotted;
      }
      */
      /* Style for Tippy tooltips */
      .tippy-box[data-theme~="light-border"] {
        border: 1px solid #ccc;
        white-space: pre-wrap; /* Allow line breaks in tooltips */
      }
    </style>
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link
      href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;700&display=swap"
      rel="stylesheet"
    />
  </head>
  <body class="bg-gray-100 p-4 md:p-8">
    <div class="container mx-auto max-w-6xl bg-white p-6 rounded-lg shadow-lg">
      <h1 class="text-2xl md:text-3xl font-bold text-center text-gray-800 mb-6">
        Tr√¨nh t·∫°o s∆° ƒë·ªì PERT (Chuy·ªÉn ƒë·ªïi t·ª´ R)
      </h1>

      <div class="mb-6">
        <h2 class="text-xl font-semibold mb-3 text-gray-700">
          Nh·∫≠p th√¥ng tin c√¥ng vi·ªác
        </h2>
        <div class="mb-3">
          <button id="loadData1Btn" class="load-button">
            T·∫£i D·ªØ li·ªáu M·∫´u 1 (CPM)
          </button>
          <button id="loadData2Btn" class="load-button">
            T·∫£i D·ªØ li·ªáu M·∫´u 2 (CPM)
          </button>
        </div>
        <div class="overflow-x-auto">
          <table
            id="taskTable"
            class="w-full border-collapse border border-gray-300 text-sm md:text-base"
          >
            <thead>
              <tr class="bg-gray-200">
                <th class="border border-gray-300 p-2 w-1/12"></th>
                <th class="border border-gray-300 p-2 w-2/12">
                  C√¥ng vi·ªác (ID)
                </th>
                <th class="border border-gray-300 p-2 w-2/12">Th·ªùi gian TH</th>
                <th class="border border-gray-300 p-2 w-6/12">
                  C√¥ng vi·ªác tr∆∞·ªõc (vd: X1,X2)
                </th>
                <th class="border border-gray-300 p-2 w-1/12"></th>
              </tr>
            </thead>
            <tbody></tbody>
          </table>
        </div>
        <button
          id="addRowBtn"
          class="mt-3 mr-2 px-4 py-2 bg-blue-500 text-white rounded hover:bg-blue-600 transition-colors duration-150"
        >
          ‚ûï Th√™m c√¥ng vi·ªác
        </button>
        <button
          id="calculateBtn"
          class="mt-3 px-4 py-2 bg-green-500 text-white rounded hover:bg-green-600 transition-colors duration-150"
        >
          üìä T√≠nh to√°n & V·∫Ω s∆° ƒë·ªì
        </button>
        <div
          id="errorMessage"
          class="mt-4 text-red-600 font-semibold hidden"
        ></div>
      </div>

      <div class="mb-6">
        <h2 class="text-xl font-semibold mb-3 text-gray-700">
          S∆° ƒë·ªì PERT/CPM (K√©o th·∫£ c√°c n√∫t ƒë·ªÉ ƒëi·ªÅu ch·ªânh)
        </h2>
        <div
          id="pertChart"
          class="bg-gray-50 p-4 rounded border border-gray-300 min-h-[500px] flex items-center justify-center overflow-hidden"
        >
          <span class="text-gray-500"
            >S∆° ƒë·ªì s·∫Ω ƒë∆∞·ª£c hi·ªÉn th·ªã ·ªü ƒë√¢y sau khi t√≠nh to√°n.</span
          >
        </div>
        <div class="mt-4 text-sm text-gray-600">
          <p>
            <span class="font-bold text-red-600">ES (G√≥c tr√°i):</span> Th·ªùi gian
            s·ªõm nh·∫•t s·ª± ki·ªán c√≥ th·ªÉ x·∫£y ra.
          </p>
          <p>
            <span class="font-bold text-blue-600">LF (G√≥c ph·∫£i):</span> Th·ªùi
            gian mu·ªôn nh·∫•t s·ª± ki·ªán ph·∫£i x·∫£y ra.
          </p>
          <p>
            <span class="font-bold text-purple-600">Slack (G√≥c d∆∞·ªõi):</span>
            Th·ªùi gian d·ª± tr·ªØ c·ªßa s·ª± ki·ªán (LF - ES).
          </p>
          <p>
            <span class="font-bold text-gray-700">ID (G√≥c tr√™n):</span> M√£ ƒë·ªãnh
            danh c·ªßa s·ª± ki·ªán.
          </p>
          <p>
            <span class="font-bold text-orange-600">ƒê∆∞·ªùng gƒÉng:</span> C√°c c√¥ng
            vi·ªác v√† s·ª± ki·ªán c√≥ Slack = 0.
          </p>
        </div>
      </div>

      <div class="mb-6">
        <h2 class="text-xl font-semibold mb-3 text-gray-700">
          K·∫øt qu·∫£ t√≠nh to√°n chi ti·∫øt (CPM)
        </h2>
        <div id="resultsTableContainer" class="overflow-x-auto">
          <span class="text-gray-500">K·∫øt qu·∫£ chi ti·∫øt s·∫Ω hi·ªÉn th·ªã ·ªü ƒë√¢y.</span>
        </div>
      </div>
    </div>

    <script>
      // --- DOM Elements ---
      const taskTableBody = document.querySelector("#taskTable tbody");
      const addRowBtn = document.getElementById("addRowBtn");
      const calculateBtn = document.getElementById("calculateBtn");
      const pertChartContainer = document.getElementById("pertChart");
      const resultsTableContainer = document.getElementById(
        "resultsTableContainer"
      );
      const errorMessageDiv = document.getElementById("errorMessage");
      const loadData1Btn = document.getElementById("loadData1Btn");
      const loadData2Btn = document.getElementById("loadData2Btn");

      // --- Constants ---
      const SVG_NS = "http://www.w3.org/2000/svg";
      const NODE_RADIUS = 30;
      const H_SPACING = 150;
      const V_SPACING = 100;
      const PADDING = 50;

      // --- Sample Data (CPM format) ---
      const sampleData1 = [
        { id: "X1", duration: 3, dependencies: "" },
        { id: "X2", duration: 3, dependencies: "" },
        { id: "X3", duration: 5, dependencies: "" },
        { id: "X4", duration: 3, dependencies: "X3" },
        { id: "X5", duration: 4, dependencies: "X1" },
        { id: "X6", duration: 5, dependencies: "X1" },
        { id: "X7", duration: 3, dependencies: "X2,X4" },
        { id: "X8", duration: 4, dependencies: "X6" },
        { id: "X9", duration: 4, dependencies: "X5,X7" },
        { id: "X10", duration: 5, dependencies: "X8,X9" },
        { id: "X11", duration: 4, dependencies: "X10" },
      ];
      const sampleData2 = [
        { id: "X1", duration: 3, dependencies: "" },
        { id: "X2", duration: 3, dependencies: "" },
        { id: "X3", duration: 4, dependencies: "" },
        { id: "X4", duration: 3, dependencies: "X2" },
        { id: "X5", duration: 4, dependencies: "X1" },
        { id: "X6", duration: 5, dependencies: "X1" },
        { id: "X7", duration: 3, dependencies: "X4" },
        { id: "X8", duration: 4, dependencies: "X6" },
        { id: "X9", duration: 5, dependencies: "X3,X7" },
        { id: "X10", duration: 5, dependencies: "X5,X8,X9" },
      ];

      // --- Global State for Dragging ---
      let isDragging = false;
      let selectedNodeElement = null;
      let offset = { x: 0, y: 0 };
      let svgElement = null;
      let nodesMapRef = null;
      let edgesRef = null;
      let tippyInstances = []; // To manage Tippy instances

      // --- Event Listeners ---
      addRowBtn.addEventListener("click", addRow);
      calculateBtn.addEventListener("click", handleCalculation);
      taskTableBody.addEventListener("click", handleTableActions);
      loadData1Btn.addEventListener("click", () => loadSampleData(sampleData1));
      loadData2Btn.addEventListener("click", () => loadSampleData(sampleData2));

      // --- Functions ---

      // --- Tippy Initialization ---
      function initializeTippy() {
        // Destroy previous instances if any
        tippyInstances.forEach((instance) => instance.destroy());
        tippyInstances = [];

        // Initialize Tippy for table cells and SVG text elements
        const newInstances = tippy("[data-tippy-content]", {
          allowHTML: true, // Allow HTML in tooltips if needed later
          theme: "light-border", // Use a theme with a border
          placement: "top", // Default placement
          delay: 0, // Show instantly
          duration: [100, 100], // Fade in/out duration
          interactive: false, // Tooltip is not interactive
          appendTo: () => document.body, // Append to body to avoid SVG clipping issues
        });
        if (Array.isArray(newInstances)) {
          tippyInstances = newInstances;
        } else if (newInstances) {
          tippyInstances.push(newInstances); // Handle single instance case
        }
      }

      // --- Data Loading ---
      function loadSampleData(data) {
        taskTableBody.innerHTML = ""; // Clear existing rows
        data.forEach((task) => {
          const newRow = createTableRow();
          newRow.querySelector(".task-id").value = task.id;
          newRow.querySelector(".duration").value = task.duration;
          newRow.querySelector(".dependencies").value = task.dependencies;
          taskTableBody.appendChild(newRow);
        });
        pertChartContainer.innerHTML =
          '<span class="text-gray-500">S∆° ƒë·ªì s·∫Ω ƒë∆∞·ª£c hi·ªÉn th·ªã ·ªü ƒë√¢y sau khi t√≠nh to√°n.</span>';
        resultsTableContainer.innerHTML =
          '<span class="text-gray-500">K·∫øt qu·∫£ chi ti·∫øt s·∫Ω hi·ªÉn th·ªã ·ªü ƒë√¢y.</span>';
        clearError();
        removeDragListeners();
        // Destroy Tippy instances when loading new data
        tippyInstances.forEach((instance) => instance.destroy());
        tippyInstances = [];
      }

      // (Helper functions: handleTableActions, createTableRow, addRow, removeRow, insertRowAbove, displayError, clearError - No changes)
      function handleTableActions(event) {
        if (event.target.classList.contains("remove-row")) {
          removeRow(event.target);
        } else if (event.target.classList.contains("insert-row")) {
          insertRowAbove(event.target);
        }
      }
      function createTableRow() {
        const newRow = document.createElement("tr");
        newRow.innerHTML = ` <td class="border border-gray-300 p-1 text-center"><button class="action-button insert-row" title="Ch√®n d√≤ng v√†o tr√™n">‚¨ÜÔ∏è</button></td> <td class="border border-gray-300 p-1"><input type="text" class="w-full p-1 border rounded text-center task-id" placeholder="T√™n CV"></td> <td class="border border-gray-300 p-1"><input type="number" min="0" class="w-full p-1 border rounded text-center duration" placeholder="TG"></td> <td class="border border-gray-300 p-1"><input type="text" class="w-full p-1 border rounded text-center dependencies" placeholder="CV tr∆∞·ªõc"></td> <td class="border border-gray-300 p-1 text-center"><button class="action-button remove-row" title="X√≥a d√≤ng">üóëÔ∏è</button></td> `;
        return newRow;
      }
      function addRow() {
        const newRow = createTableRow();
        taskTableBody.appendChild(newRow);
      }
      function removeRow(button) {
        const row = button.closest("tr");
        if (taskTableBody.rows.length > 0) {
          row.remove();
        } else {
          displayError("Kh√¥ng c√≤n c√¥ng vi·ªác n√†o ƒë·ªÉ x√≥a.");
        }
      }
      function insertRowAbove(button) {
        const currentRow = button.closest("tr");
        const newRow = createTableRow();
        taskTableBody.insertBefore(newRow, currentRow);
      }
      function displayError(message) {
        errorMessageDiv.textContent = message;
        errorMessageDiv.classList.remove("hidden");
      }
      function clearError() {
        errorMessageDiv.textContent = "";
        errorMessageDiv.classList.add("hidden");
      }

      // --- Main Calculation Handler ---
      function handleCalculation() {
        clearError();
        pertChartContainer.innerHTML =
          '<span class="text-gray-500">ƒêang t√≠nh to√°n v√† v·∫Ω s∆° ƒë·ªì...</span>';
        resultsTableContainer.innerHTML =
          '<span class="text-gray-500">ƒêang t√≠nh to√°n k·∫øt qu·∫£...</span>';
        removeDragListeners();
        // Destroy previous Tippy instances before recalculating
        tippyInstances.forEach((instance) => instance.destroy());
        tippyInstances = [];

        try {
          const tasks = parseInputData();
          if (!tasks) return;
          if (tasks.length === 0) {
            displayError("Vui l√≤ng nh·∫≠p √≠t nh·∫•t m·ªôt c√¥ng vi·ªác.");
            pertChartContainer.innerHTML =
              '<span class="text-gray-500">Ch∆∞a c√≥ d·ªØ li·ªáu ƒë·ªÉ v·∫Ω s∆° ƒë·ªì.</span>';
            resultsTableContainer.innerHTML =
              '<span class="text-gray-500">Ch∆∞a c√≥ d·ªØ li·ªáu ƒë·ªÉ t√≠nh to√°n.</span>';
            return;
          }

          const { nodes, edges, startNodeId, endNodeId } = buildGraph(tasks);
          if (!nodes || !edges) return;

          calculatePert(nodes, edges, startNodeId, endNodeId);

          nodesMapRef = nodes;
          edgesRef = edges;

          drawPertChart(nodes, edges, startNodeId, endNodeId);
          displayResultsTable(tasks, nodes);

          // Initialize Tippy AFTER elements are rendered
          initializeTippy();
        } catch (error) {
          console.error("L·ªói trong qu√° tr√¨nh t√≠nh to√°n PERT/CPM:", error);
          displayError(
            `ƒê√£ x·∫£y ra l·ªói: ${error.message}. Vui l√≤ng ki·ªÉm tra l·∫°i d·ªØ li·ªáu nh·∫≠p ho·∫∑c c·∫•u tr√∫c ph·ª• thu·ªôc.`
          );
          pertChartContainer.innerHTML =
            '<span class="text-red-500">Kh√¥ng th·ªÉ t·∫°o s∆° ƒë·ªì do l·ªói.</span>';
          resultsTableContainer.innerHTML =
            '<span class="text-red-500">Kh√¥ng th·ªÉ hi·ªÉn th·ªã k·∫øt qu·∫£ do l·ªói.</span>';
        }
      }

      // --- Parse Input Data (No changes needed here) ---
      function parseInputData() {
        const tasks = [];
        const taskIds = new Set();
        const rows = taskTableBody.querySelectorAll("tr");
        let hasError = false;
        if (rows.length === 0) return [];

        rows.forEach((row, index) => {
          const idInput = row.querySelector(".task-id");
          const durationInput = row.querySelector(".duration");
          const dependenciesInput = row.querySelector(".dependencies");
          if (!idInput || !durationInput || !dependenciesInput) {
            console.error(`Missing input elements in row ${index + 1}`);
            hasError = true;
            return;
          }
          const id = idInput.value.trim().toUpperCase();
          const durationStr = durationInput.value;
          const dependenciesStr = dependenciesInput.value.trim().toUpperCase();

          if (!id) {
            displayError(
              `L·ªói ·ªü d√≤ng ${index + 1}: T√™n c√¥ng vi·ªác (ID) kh√¥ng ƒë∆∞·ª£c ƒë·ªÉ tr·ªëng.`
            );
            idInput.focus();
            hasError = true;
            return;
          }
          if (taskIds.has(id)) {
            displayError(
              `L·ªói ·ªü d√≤ng ${
                index + 1
              }: T√™n c√¥ng vi·ªác (ID) "${id}" b·ªã tr√πng l·∫∑p.`
            );
            idInput.focus();
            hasError = true;
            return;
          }
          const duration = parseFloat(durationStr);
          if (isNaN(duration) || duration < 0) {
            displayError(
              `L·ªói ·ªü d√≤ng ${
                index + 1
              }: Th·ªùi gian th·ª±c hi·ªán c·ªßa c√¥ng vi·ªác "${id}" kh√¥ng h·ª£p l·ªá (ph·∫£i l√† s·ªë kh√¥ng √¢m).`
            );
            durationInput.focus();
            hasError = true;
            return;
          }
          taskIds.add(id);
          const dependencies =
            dependenciesStr === "" ||
            dependenciesStr.toLowerCase() === "ngay t·ª´ ƒë·∫ßu" ||
            dependenciesStr === "-"
              ? []
              : dependenciesStr
                  .split(",")
                  .map((dep) => dep.trim().toUpperCase())
                  .filter((dep) => dep !== "");
          tasks.push({
            id,
            duration,
            dependencies,
            es: 0,
            ef: 0,
            ls: 0,
            lf: 0,
            slack: 0,
            isCritical: false,
            startNodeId: null,
            endNodeId: null,
          });
        });

        if (!hasError) {
          tasks.forEach((task, index) => {
            task.dependencies.forEach((depId) => {
              if (!taskIds.has(depId)) {
                const row = taskTableBody.querySelectorAll("tr")[index];
                displayError(
                  `L·ªói ·ªü d√≤ng ${index + 1}: C√¥ng vi·ªác "${
                    task.id
                  }" ph·ª• thu·ªôc v√†o c√¥ng vi·ªác kh√¥ng t·ªìn t·∫°i "${depId}".`
                );
                if (row) row.querySelector(".dependencies")?.focus();
                hasError = true;
              }
            });
          });
        }
        return hasError ? null : tasks;
      }

      // --- General Graph Building Logic (No changes needed here) ---
      function buildGraph(tasks) {
        const nodes = new Map();
        const edges = [];
        const taskMap = new Map(tasks.map((task) => [task.id, task]));
        let nextNodeId = 0;

        function getNode(id) {
          if (!nodes.has(id)) {
            nodes.set(id, {
              id: id,
              es: 0,
              lf: Infinity,
              x: 0,
              y: 0,
              incomingEdges: [],
              outgoingEdges: [],
              layer: -1,
              gElement: null,
              esCalculation: null,
              lfCalculation: null,
              slackCalculation: null,
            });
          }
          return nodes.get(id);
        }

        const startNode = getNode(nextNodeId++);
        const taskEndNodes = new Map();
        const mergeNodes = new Map();

        tasks.forEach((task) => {
          if (task.dependencies.length === 0) {
            task.startNodeId = startNode.id;
          } else {
            const depKey = JSON.stringify([...task.dependencies].sort());
            if (mergeNodes.has(depKey)) {
              task.startNodeId = mergeNodes.get(depKey);
            } else {
              let commonEndNodeId = null;
              let firstDepEndNodeId = null;
              let allDepsHaveEndNode = true;
              for (const depId of task.dependencies) {
                const knownEndNode = taskEndNodes.get(depId);
                if (knownEndNode === undefined) {
                  allDepsHaveEndNode = false;
                  break;
                }
                if (firstDepEndNodeId === null) {
                  firstDepEndNodeId = knownEndNode;
                  commonEndNodeId = knownEndNode;
                } else if (knownEndNode !== commonEndNodeId) {
                  commonEndNodeId = -1;
                  break;
                }
              }
              if (
                allDepsHaveEndNode &&
                commonEndNodeId !== -1 &&
                commonEndNodeId !== null
              ) {
                task.startNodeId = commonEndNodeId;
                mergeNodes.set(depKey, commonEndNodeId);
              } else {
                const newNode = getNode(nextNodeId++);
                task.startNodeId = newNode.id;
                mergeNodes.set(depKey, newNode.id);
                task.dependencies.forEach((depId) => {
                  if (!taskEndNodes.has(depId)) {
                    taskEndNodes.set(depId, newNode.id);
                  } else if (taskEndNodes.get(depId) !== newNode.id) {
                    console.warn(
                      `Task ${task.id} starts at new node ${
                        newNode.id
                      }, but dependency ${depId} already ends at ${taskEndNodes.get(
                        depId
                      )}. Dummy task might be needed.`
                    );
                    taskEndNodes.set(depId, newNode.id);
                  }
                });
              }
            }
          }
        });

        const tasksWithSuccessors = new Set();
        tasks.forEach((task) =>
          task.dependencies.forEach((depId) => tasksWithSuccessors.add(depId))
        );

        tasks.forEach((task) => {
          if (!taskEndNodes.has(task.id)) {
            if (!tasksWithSuccessors.has(task.id)) {
              task.endNodeId = getNode(nextNodeId++).id;
            } else {
              task.endNodeId = getNode(nextNodeId++).id;
              taskEndNodes.set(task.id, task.endNodeId);
            }
          } else {
            task.endNodeId = taskEndNodes.get(task.id);
          }
          const startN = getNode(task.startNodeId);
          const endN = getNode(task.endNodeId);
          if (startN && endN) {
            task.esCalculation = null;
            task.efCalculation = null;
            task.lsCalculation = null;
            task.lfCalculation = null;
            task.slackCalculation = null;
            task.isDummy = false;
            startN.outgoingEdges.push(task);
            endN.incomingEdges.push(task);
            edges.push(task);
          } else {
            throw new Error(`L·ªói t·∫°o ƒë·ªì th·ªã cho c√¥ng vi·ªác ${task.id}.`);
          }
        });

        let finalEndNode;
        const actualEndNodes = Array.from(nodes.values()).filter(
          (n) =>
            n.id !== startNode.id &&
            n.outgoingEdges.filter((e) => !e.isDummy).length === 0
        );

        if (actualEndNodes.length === 1) {
          finalEndNode = actualEndNodes[0];
        } else if (actualEndNodes.length > 1) {
          finalEndNode = getNode(nextNodeId++);
          actualEndNodes.forEach((node) => {
            const dummyTask = {
              id: `dummy_end_${node.id}`,
              duration: 0,
              dependencies: [],
              startNodeId: node.id,
              endNodeId: finalEndNode.id,
              es: 0,
              ef: 0,
              ls: 0,
              lf: 0,
              slack: 0,
              isCritical: false,
              isDummy: true,
              gElement: null,
              pathElement: null,
              textElement: null,
              textBgElement: null,
              esCalculation: "Dummy Task",
              efCalculation: "Dummy Task",
              lsCalculation: "Dummy Task",
              lfCalculation: "Dummy Task",
              slackCalculation: "Dummy Task",
            };
            node.outgoingEdges.push(dummyTask);
            finalEndNode.incomingEdges.push(dummyTask);
            edges.push(dummyTask);
          });
        } else if (nodes.size > 1) {
          console.warn(
            "Kh√¥ng t√¨m th·∫•y n√∫t k·∫øt th√∫c r√µ r√†ng. C·∫ßn ki·ªÉm tra l·∫°i logic ho·∫∑c d·ªØ li·ªáu."
          );
          const maxId = Math.max(...Array.from(nodes.keys()));
          finalEndNode = nodes.get(maxId) || startNode;
          if (finalEndNode === startNode) {
            throw new Error("Kh√¥ng th·ªÉ x√°c ƒë·ªãnh n√∫t k·∫øt th√∫c.");
          }
          console.warn(
            "S·ª≠ d·ª•ng n√∫t c√≥ ID cao nh·∫•t l√†m n√∫t k·∫øt th√∫c t·∫°m th·ªùi:",
            finalEndNode.id
          );
        } else {
          finalEndNode = startNode;
        }

        const visited = new Set();
        const recursionStack = new Set();
        function detectCycleUtil(nodeId) {
          const node = nodes.get(nodeId);
          if (!node) return false;
          visited.add(nodeId);
          recursionStack.add(nodeId);
          for (const edge of node.outgoingEdges) {
            const neighborNodeId = edge.endNodeId;
            if (!visited.has(neighborNodeId)) {
              if (detectCycleUtil(neighborNodeId)) return true;
            } else if (recursionStack.has(neighborNodeId)) {
              return true;
            }
          }
          recursionStack.delete(nodeId);
          return false;
        }
        if (nodes.size > 0 && detectCycleUtil(startNode.id)) {
          throw new Error("ƒê·ªì th·ªã c√¥ng vi·ªác ch·ª©a v√≤ng l·∫∑p.");
        }

        return {
          nodes,
          edges,
          startNodeId: startNode.id,
          endNodeId: finalEndNode.id,
        };
      }

      // --- Calculate PERT (Standard calculation - No changes needed here) ---
      function calculatePert(nodes, edges, startNodeId, endNodeId) {
        console.log("Running standard PERT calculation...");
        const nodeList = Array.from(nodes.values());

        nodeList.forEach((node) => {
          node.es = 0;
          node.esCalculation = "Start Node = 0";
          node.lf = Infinity;
          node.lfCalculation = "Infinity (init)";
          node.slackCalculation = null;
        });

        const inDegree = new Map();
        nodeList.forEach((node) =>
          inDegree.set(node.id, node.incomingEdges.length)
        );
        const queue = nodeList.filter((node) => inDegree.get(node.id) === 0);
        const topologicalOrder = [];
        let processedEdges = 0;

        while (queue.length > 0) {
          const uNode = queue.shift();
          topologicalOrder.push(uNode);
          uNode.outgoingEdges.forEach((edge) => {
            processedEdges++;
            const vNode = nodes.get(edge.endNodeId);
            if (vNode) {
              const potential_es = uNode.es + edge.duration;
              if (
                !vNode.esCalculation ||
                vNode.esCalculation === "Start Node = 0"
              ) {
                vNode.esCalculation = [];
              }
              if (Array.isArray(vNode.esCalculation)) {
                vNode.esCalculation.push(
                  `Max(..., Node ${uNode.id} ES + Edge ${edge.id} Dur) = Max(..., ${uNode.es} + ${edge.duration} = ${potential_es})`
                );
              }
              if (potential_es > vNode.es) {
                vNode.es = potential_es;
              }
              edge.es = uNode.es;
              edge.ef = edge.es + edge.duration;
              edge.esCalculation = `ES = Start Node (${edge.startNodeId}) ES = ${uNode.es}`;
              edge.efCalculation = `EF = Edge ES + Duration = ${edge.es} + ${edge.duration} = ${edge.ef}`;
              inDegree.set(vNode.id, inDegree.get(vNode.id) - 1);
              if (inDegree.get(vNode.id) === 0) {
                queue.push(vNode);
              }
            }
          });
        }

        if (topologicalOrder.length !== nodes.size) {
          console.error(
            "Topological sort failed. Graph likely contains a cycle."
          );
          throw new Error(
            "ƒê·ªì th·ªã ch·ª©a v√≤ng l·∫∑p, kh√¥ng th·ªÉ th·ª±c hi·ªán t√≠nh to√°n PERT."
          );
        }

        const endNode = nodes.get(endNodeId);
        let projectDuration = 0;
        if (endNode) {
          projectDuration = endNode.es;
        } else {
          projectDuration = Math.max(0, ...nodeList.map((n) => n.es));
          console.warn(
            `End node ${endNodeId} not found/reachable. Using max ES ${projectDuration}.`
          );
        }

        nodeList.forEach((node) => {
          node.lf = projectDuration;
          node.lfCalculation = `Project Duration = ${projectDuration}`;
        });
        if (endNode) {
          endNode.lf = projectDuration;
          endNode.lfCalculation = `End Node LF = Project Duration = ${projectDuration}`;
        }

        for (let i = topologicalOrder.length - 1; i >= 0; i--) {
          const uNode = topologicalOrder[i];
          if (uNode.outgoingEdges.length > 0) {
            uNode.lfCalculation = [];
            uNode.outgoingEdges.forEach((outgoingEdge) => {
              const nextNode = nodes.get(outgoingEdge.endNodeId);
              if (nextNode) {
                const potential_lf_for_u = nextNode.lf - outgoingEdge.duration;
                uNode.lfCalculation.push(
                  `Min(..., Node ${nextNode.id} LF - Edge ${outgoingEdge.id} Dur) = Min(..., ${nextNode.lf} - ${outgoingEdge.duration} = ${potential_lf_for_u})`
                );
              }
            });
          } else if (uNode.id !== endNodeId) {
            uNode.lfCalculation = `Terminal Node LF = Project Duration = ${projectDuration}`;
          }
          uNode.incomingEdges.forEach((edge) => {
            const vNode = nodes.get(edge.startNodeId);
            if (vNode) {
              const potential_lf = uNode.lf - edge.duration;
              if (potential_lf < vNode.lf) {
                vNode.lf = potential_lf;
              }
              edge.lf = uNode.lf;
              edge.ls = edge.lf - edge.duration;
              edge.lfCalculation = `LF = End Node (${edge.endNodeId}) LF = ${uNode.lf}`;
              edge.lsCalculation = `LS = Edge LF - Duration = ${edge.lf} - ${edge.duration} = ${edge.ls}`;
            }
          });
        }

        const tolerance = 0.001;
        edges.forEach((edge) => {
          const startNode = nodes.get(edge.startNodeId);
          const endNode = nodes.get(edge.endNodeId);
          if (startNode && endNode && !edge.isDummy) {
            edge.slack = edge.ls - edge.es;
            const roundedSlack = Math.round(edge.slack * 1000) / 1000;
            edge.slackCalculation = `Slack = LS - ES = ${edge.ls} - ${edge.es} = ${roundedSlack}`;
            const startNodeSlack =
              Math.round((startNode.lf - startNode.es) * 1000) / 1000;
            const endNodeSlack =
              Math.round((endNode.lf - endNode.es) * 1000) / 1000;
            edge.isCritical =
              Math.abs(roundedSlack) < tolerance &&
              Math.abs(startNodeSlack) < tolerance &&
              Math.abs(endNodeSlack) < tolerance;
            if (edge.isCritical) edge.slack = 0;
          } else {
            edge.slack = NaN;
            edge.isCritical = false;
            edge.slackCalculation = edge.isDummy
              ? "Dummy Task"
              : "Cannot calculate";
          }
        });

        nodeList.forEach((node) => {
          node.slack = node.lf - node.es;
          const roundedSlack = Math.round(node.slack * 1000) / 1000;
          node.slackCalculation = `Node Slack = Node LF - Node ES = ${node.lf} - ${node.es} = ${roundedSlack}`;
          node.isCritical = Math.abs(roundedSlack) < tolerance;
          if (node.isCritical) node.slack = 0;
          if (Array.isArray(node.esCalculation)) {
            node.esCalculation = node.esCalculation.join("; ");
          }
          if (Array.isArray(node.lfCalculation)) {
            node.lfCalculation = node.lfCalculation.join("; ");
          }
        });
        console.log("Standard PERT calculation complete.");
      }

      // --- Draw PERT Chart ---
      function drawPertChart(nodesMap, edges, startNodeId, endNodeId) {
        pertChartContainer.innerHTML = ""; // Clear previous chart
        svgElement = document.createElementNS(SVG_NS, "svg");
        const defs = document.createElementNS(SVG_NS, "defs");
        const marker = createMarker("arrowhead", "#666");
        const markerCritical = createMarker("arrowhead-critical", "orange");
        defs.appendChild(marker);
        defs.appendChild(markerCritical);
        svgElement.appendChild(defs);

        const nodes = Array.from(nodesMap.values());

        // Layout Nodes (Simple Layered Approach - No changes needed)
        const layers = new Map();
        const nodeLayer = new Map();
        const sortedNodes = [...nodes].sort(
          (a, b) => a.es - b.es || a.id - b.id
        );
        let maxLayer = 0;
        const esToLayer = new Map();
        let currentLayerIndex = 0;
        sortedNodes.forEach((node) => {
          const esRounded = Math.round(node.es * 100) / 100;
          if (!esToLayer.has(esRounded)) {
            esToLayer.set(esRounded, currentLayerIndex++);
          }
          node.layer = esToLayer.get(esRounded);
          maxLayer = Math.max(maxLayer, node.layer);
          if (!layers.has(node.layer)) layers.set(node.layer, []);
          layers.get(node.layer).push(node.id);
          nodeLayer.set(node.id, node.layer);
        });
        let maxNodesInLayer = 0;
        layers.forEach(
          (layerNodes) =>
            (maxNodesInLayer = Math.max(maxNodesInLayer, layerNodes.length))
        );
        const layerContentHeight =
          maxNodesInLayer > 1 ? (maxNodesInLayer - 1) * V_SPACING : 0;
        const totalHeight =
          PADDING * 2 + Math.max(layerContentHeight, NODE_RADIUS * 2);
        const totalWidth =
          PADDING * 2 + (maxLayer > 0 ? maxLayer * H_SPACING : NODE_RADIUS * 2);
        svgElement.setAttribute(
          "viewBox",
          `0 0 ${Math.max(totalWidth, 600)} ${Math.max(totalHeight, 500)}`
        );
        svgElement.setAttribute("preserveAspectRatio", "xMidYMid meet");
        layers.forEach((nodeIdsInLayer, layerIndex) => {
          const layerNodeCount = nodeIdsInLayer.length;
          const layerHeight =
            layerNodeCount > 1 ? (layerNodeCount - 1) * V_SPACING : 0;
          const remainingHeight = totalHeight - PADDING * 2;
          const startY =
            PADDING + Math.max(0, (remainingHeight - layerHeight) / 2);
          const sortedNodeIds = nodeIdsInLayer.sort((a, b) => a - b);
          sortedNodeIds.forEach((nodeId, nodeIndex) => {
            const node = nodesMap.get(nodeId);
            node.x = PADDING + node.layer * H_SPACING;
            node.y = startY + nodeIndex * V_SPACING;
          });
        });

        // Draw Edges & Nodes
        const edgeGroup = document.createElementNS(SVG_NS, "g");
        edgeGroup.setAttribute("class", "edges");
        edges.forEach((edge) => drawEdge(edge, edgeGroup, nodesMap));
        svgElement.appendChild(edgeGroup);
        const nodeGroup = document.createElementNS(SVG_NS, "g");
        nodeGroup.setAttribute("class", "nodes");
        nodes.forEach((node) => {
          drawNode(node, nodeGroup);
          node.gElement = nodeGroup.lastChild;
        });
        svgElement.appendChild(nodeGroup);
        pertChartContainer.appendChild(svgElement);
        addDragListeners();
      }

      // --- Helper to create marker (No changes) ---
      function createMarker(id, color) {
        const marker = document.createElementNS(SVG_NS, "marker");
        marker.setAttribute("id", id);
        marker.setAttribute("markerWidth", "10");
        marker.setAttribute("markerHeight", "7");
        marker.setAttribute("refX", "9");
        marker.setAttribute("refY", "3.5");
        marker.setAttribute("orient", "auto");
        const polygon = document.createElementNS(SVG_NS, "polygon");
        polygon.setAttribute("points", "0 0, 10 3.5, 0 7");
        polygon.setAttribute("fill", color);
        marker.appendChild(polygon);
        return marker;
      }

      // --- Helper to draw node (UPDATED: Use data-tippy-content) ---
      function drawNode(node, parentGroup) {
        const nodeElement = document.createElementNS(SVG_NS, "g");
        nodeElement.setAttribute(
          "class",
          `node ${node.isCritical ? "critical" : ""}`
        );
        nodeElement.setAttribute(
          "transform",
          `translate(${node.x}, ${node.y})`
        );
        nodeElement.setAttribute("data-node-id", node.id);

        const circle = document.createElementNS(SVG_NS, "circle");
        circle.setAttribute("r", NODE_RADIUS);
        nodeElement.appendChild(circle);

        const r = NODE_RADIUS * 0.95;
        const lineOffset = r / Math.sqrt(2);
        const line1 = document.createElementNS(SVG_NS, "line");
        line1.setAttribute("class", "divider");
        line1.setAttribute("x1", -lineOffset);
        line1.setAttribute("y1", -lineOffset);
        line1.setAttribute("x2", lineOffset);
        line1.setAttribute("y2", lineOffset);
        nodeElement.appendChild(line1);
        const line2 = document.createElementNS(SVG_NS, "line");
        line2.setAttribute("class", "divider");
        line2.setAttribute("x1", lineOffset);
        line2.setAttribute("y1", -lineOffset);
        line2.setAttribute("x2", -lineOffset);
        line2.setAttribute("y2", lineOffset);
        nodeElement.appendChild(line2);

        const textOffset = NODE_RADIUS * 0.5;

        // Use data-tippy-content instead of <title> element
        const nodeIdText = createTextElement(
          "node-id",
          0,
          -textOffset,
          node.id
        );
        nodeIdText.setAttribute("data-tippy-content", `Node ID: ${node.id}`);
        nodeElement.appendChild(nodeIdText);

        const esText = createTextElement("es-text", -textOffset, 0, node.es);
        esText.setAttribute(
          "data-tippy-content",
          `Node ES: ${node.es}<br>Calculation: ${node.esCalculation || "N/A"}`
        );
        nodeElement.appendChild(esText);

        const lfText = createTextElement("lf-text", textOffset, 0, node.lf);
        lfText.setAttribute(
          "data-tippy-content",
          `Node LF: ${node.lf}<br>Calculation: ${node.lfCalculation || "N/A"}`
        );
        nodeElement.appendChild(lfText);

        const slackText = createTextElement(
          "slack-text",
          0,
          textOffset,
          node.slack
        );
        slackText.setAttribute(
          "data-tippy-content",
          `Node Slack: ${node.slack}<br>Calculation: ${
            node.slackCalculation || "N/A"
          }`
        );
        nodeElement.appendChild(slackText);

        parentGroup.appendChild(nodeElement);
      }

      // --- Helper to create text element (REMOVED title parameter) ---
      function createTextElement(className, x, y, content) {
        const text = document.createElementNS(SVG_NS, "text");
        text.setAttribute("class", className);
        text.setAttribute("x", x);
        text.setAttribute("y", y);
        text.textContent = content;
        // REMOVED title element creation
        return text;
      }

      // --- Helper to draw/update edge (UPDATED: Use data-tippy-content) ---
      function drawEdge(edge, parentGroup, nodesMap) {
        const startNode = nodesMap.get(edge.startNodeId);
        const endNode = nodesMap.get(edge.endNodeId);
        if (!startNode || !endNode) return;
        const { startX, startY, endX, endY, angle, midX, midY } =
          calculateEdgePoints(startNode, endNode);
        let edgeElement = edge.gElement;

        if (!edgeElement) {
          edgeElement = document.createElementNS(SVG_NS, "g");
          edgeElement.setAttribute(
            "class",
            `edge ${edge.isCritical ? "critical" : ""} ${
              edge.isDummy ? "dummy" : ""
            }`
          );
          edgeElement.setAttribute("data-edge-id", edge.id);
          const path = document.createElementNS(SVG_NS, "path");
          path.setAttribute(
            "marker-end",
            `url(#${edge.isCritical ? "arrowhead-critical" : "arrowhead"})`
          );
          if (edge.isDummy) path.setAttribute("stroke-dasharray", "5,5");
          edgeElement.appendChild(path);
          edge.pathElement = path;
          if (!edge.isDummy) {
            const text = document.createElementNS(SVG_NS, "text");
            edgeElement.appendChild(text);
            edge.textElement = text;
            // REMOVED title element creation
          }
          parentGroup.appendChild(edgeElement);
          edge.gElement = edgeElement;
        } else {
          edgeElement.setAttribute(
            "class",
            `edge ${edge.isCritical ? "critical" : ""} ${
              edge.isDummy ? "dummy" : ""
            }`
          );
          edge.pathElement.setAttribute(
            "marker-end",
            `url(#${edge.isCritical ? "arrowhead-critical" : "arrowhead"})`
          );
          if (edge.isDummy)
            edge.pathElement.setAttribute("stroke-dasharray", "5,5");
          else edge.pathElement.removeAttribute("stroke-dasharray");
        }

        edge.pathElement.setAttribute(
          "d",
          `M ${startX},${startY} L ${endX},${endY}`
        );

        if (!edge.isDummy && edge.textElement) {
          const textOffset = -10;
          const textX = midX + textOffset * Math.sin((angle * Math.PI) / 180);
          const textY = midY - textOffset * Math.cos((angle * Math.PI) / 180);
          edge.textElement.setAttribute("x", textX);
          edge.textElement.setAttribute("y", textY);
          edge.textElement.textContent = `${edge.id} (${edge.duration})`; // Set text content directly

          // Set tooltip content using data-tippy-content
          const tippyContent = `Task: ${edge.id}<br>Duration: ${
            edge.duration
          }<br>ES: ${edge.es} (${edge.esCalculation || "N/A"})<br>EF: ${
            edge.ef
          } (${edge.efCalculation || "N/A"})<br>LS: ${edge.ls} (${
            edge.lsCalculation || "N/A"
          })<br>LF: ${edge.lf} (${edge.lfCalculation || "N/A"})<br>Slack: ${
            edge.slack
          } (${edge.slackCalculation || "N/A"})`;
          edge.textElement.setAttribute("data-tippy-content", tippyContent);
        }
      }

      // --- Helper to calculate edge points (No changes) ---
      function calculateEdgePoints(startNode, endNode) {
        const dx = endNode.x - startNode.x;
        const dy = endNode.y - startNode.y;
        const dist = Math.sqrt(dx * dx + dy * dy);
        let startX = startNode.x,
          startY = startNode.y,
          endX = endNode.x,
          endY = endNode.y;
        let angle = Math.atan2(dy, dx);
        if (dist > NODE_RADIUS * 2) {
          const startRatio = NODE_RADIUS / dist;
          const endRatio = (dist - NODE_RADIUS) / dist;
          startX = startNode.x + dx * startRatio;
          startY = startNode.y + dy * startRatio;
          endX = startNode.x + dx * endRatio;
          endY = startNode.y + dy * endRatio;
        } else if (dist > 0) {
          const overlapRatio = 0.4;
          startX = startNode.x + dx * overlapRatio;
          startY = startNode.y + dy * overlapRatio;
          endX = endNode.x - dx * overlapRatio;
          endY = endNode.y - dy * overlapRatio;
        }
        const midX = (startX + endX) / 2;
        const midY = (startY + endY) / 2;
        return {
          startX,
          startY,
          endX,
          endY,
          angle: (angle * 180) / Math.PI,
          midX,
          midY,
        };
      }

      // --- Drag and Drop Logic (No changes) ---
      function addDragListeners() {
        if (!svgElement) return;
        svgElement.addEventListener("mousedown", startDrag);
        svgElement.addEventListener("mousemove", drag);
        svgElement.addEventListener("mouseup", endDrag);
        svgElement.addEventListener("mouseleave", endDrag);
        svgElement.addEventListener("touchstart", startDrag, {
          passive: false,
        });
        svgElement.addEventListener("touchmove", drag, { passive: false });
        svgElement.addEventListener("touchend", endDrag);
        svgElement.addEventListener("touchcancel", endDrag);
      }
      function removeDragListeners() {
        if (!svgElement) return;
        svgElement.removeEventListener("mousedown", startDrag);
        svgElement.removeEventListener("mousemove", drag);
        svgElement.removeEventListener("mouseup", endDrag);
        svgElement.removeEventListener("mouseleave", endDrag);
        svgElement.removeEventListener("touchstart", startDrag);
        svgElement.removeEventListener("touchmove", drag);
        svgElement.removeEventListener("touchend", endDrag);
        svgElement.removeEventListener("touchcancel", endDrag);
      }
      function getMousePosition(evt) {
        if (!svgElement) return { x: 0, y: 0 };
        const CTM = svgElement.getScreenCTM();
        if (!CTM) return { x: 0, y: 0 };
        let clientX, clientY;
        if (evt.touches && evt.touches.length > 0) {
          clientX = evt.touches[0].clientX;
          clientY = evt.touches[0].clientY;
        } else if (evt.changedTouches && evt.changedTouches.length > 0) {
          clientX = evt.changedTouches[0].clientX;
          clientY = evt.changedTouches[0].clientY;
        } else if (evt.clientX && evt.clientY) {
          clientX = evt.clientX;
          clientY = evt.clientY;
        } else {
          return { x: 0, y: 0 };
        }
        return { x: (clientX - CTM.e) / CTM.a, y: (clientY - CTM.f) / CTM.d };
      }
      function startDrag(evt) {
        let targetElement = evt.target;
        while (targetElement && targetElement !== svgElement) {
          if (
            targetElement.classList &&
            targetElement.classList.contains("node")
          ) {
            selectedNodeElement = targetElement;
            break;
          }
          targetElement = targetElement.parentNode;
        }
        if (selectedNodeElement) {
          evt.preventDefault();
          isDragging = true;
          selectedNodeElement.classList.add("dragging");
          svgElement.classList.add("grabbing");
          const startPos = getMousePosition(evt);
          const transformList = selectedNodeElement.transform.baseVal;
          let currentTranslate = { e: 0, f: 0 };
          if (transformList.numberOfItems > 0) {
            const transformItem = transformList.getItem(0);
            if (transformItem.type === SVGTransform.SVG_TRANSFORM_TRANSLATE) {
              currentTranslate = transformItem.matrix;
            }
          } else {
            const newTransform = svgElement.createSVGTransform();
            newTransform.setTranslate(0, 0);
            transformList.appendItem(newTransform);
          }
          offset.x = currentTranslate.e - startPos.x;
          offset.y = currentTranslate.f - startPos.y;
        }
      }
      function drag(evt) {
        if (isDragging && selectedNodeElement) {
          evt.preventDefault();
          const coord = getMousePosition(evt);
          const newX = coord.x + offset.x;
          const newY = coord.y + offset.y;
          const transformList = selectedNodeElement.transform.baseVal;
          if (transformList.numberOfItems > 0) {
            transformList.getItem(0).setTranslate(newX, newY);
          } else {
            const newTransform = svgElement.createSVGTransform();
            newTransform.setTranslate(newX, newY);
            transformList.appendItem(newTransform);
          }
          const nodeId = parseInt(
            selectedNodeElement.getAttribute("data-node-id"),
            10
          );
          const nodeData = nodesMapRef.get(nodeId);
          if (nodeData) {
            nodeData.x = newX;
            nodeData.y = newY;
            updateConnectedEdges(nodeData);
          }
        }
      }
      function endDrag(evt) {
        if (isDragging) {
          if (selectedNodeElement) {
            selectedNodeElement.classList.remove("dragging");
          }
          if (svgElement) {
            svgElement.classList.remove("grabbing");
          }
          isDragging = false;
          selectedNodeElement = null;
        }
      }
      function updateConnectedEdges(movedNode) {
        if (!edgesRef || !nodesMapRef || !svgElement) return;
        const edgeGroup = svgElement.querySelector(".edges");
        if (!edgeGroup) return;
        movedNode.outgoingEdges.forEach((edge) =>
          drawEdge(edge, edgeGroup, nodesMapRef)
        );
        movedNode.incomingEdges.forEach((edge) =>
          drawEdge(edge, edgeGroup, nodesMapRef)
        );
      }

      // --- Display Results Table (UPDATED: Use data-tippy-content) ---
      function displayResultsTable(tasks, nodesMap) {
        resultsTableContainer.innerHTML = "";
        const edgesToDisplay = edgesRef;
        if (!edgesToDisplay || edgesToDisplay.length === 0) {
          resultsTableContainer.innerHTML =
            '<span class="text-gray-500">Kh√¥ng c√≥ d·ªØ li·ªáu c·∫°nh ƒë·ªÉ hi·ªÉn th·ªã k·∫øt qu·∫£ chi ti·∫øt.</span>';
          return;
        }
        const table = document.createElement("table");
        table.className =
          "w-full border-collapse border border-gray-300 text-sm md:text-base";
        const thead = table.createTHead();
        // Remove title attributes from table headers
        thead.innerHTML = ` <tr class="bg-gray-200"> <th class="border border-gray-300 p-2">C√¥ng vi·ªác</th> <th class="border border-gray-300 p-2">Th·ªùi gian TH</th> <th class="border border-gray-300 p-2">ES (Task)</th> <th class="border border-gray-300 p-2">EF (Task)</th> <th class="border border-gray-300 p-2">LS (Task)</th> <th class="border border-gray-300 p-2">LF (Task)</th> <th class="border border-gray-300 p-2">Slack (D·ª± tr·ªØ)</th> <th class="border border-gray-300 p-2">ƒê∆∞·ªùng gƒÉng?</th> </tr> `;
        const tbody = table.createTBody();

        const sortedEdges = [...edgesToDisplay].sort((a, b) => {
          const numA = parseInt(a.id.replace(/[^0-9]/g, ""), 10) || 0;
          const numB = parseInt(b.id.replace(/[^0-9]/g, ""), 10) || 0;
          if (numA !== numB) return numA - numB;
          return a.id.localeCompare(b.id);
        });

        sortedEdges
          .filter((task) => !task.isDummy)
          .forEach((task) => {
            const row = tbody.insertRow();
            // Helper to create cell with data-tippy-content
            const createCell = (content, tippyContent = "") => {
              const cell = document.createElement("td");
              cell.className = "border border-gray-300 p-2 text-center";
              cell.textContent = content;
              // Use data-tippy-content instead of title
              if (
                tippyContent &&
                tippyContent !== "N/A" &&
                tippyContent !== "Dummy Task"
              ) {
                cell.setAttribute("data-tippy-content", tippyContent);
                cell.style.cursor = "help"; // Add help cursor
              }
              return cell;
            };

            const createCriticalCell = (
              content,
              tippyContent = "",
              isCritical
            ) => {
              const cell = createCell(content, tippyContent);
              if (isCritical) {
                cell.classList.add("text-orange-600", "font-bold");
              }
              return cell;
            };

            row.appendChild(createCell(task.id));
            row.appendChild(createCell(task.duration));
            row.appendChild(createCell(task.es, task.esCalculation || "N/A"));
            row.appendChild(createCell(task.ef, task.efCalculation || "N/A"));
            row.appendChild(createCell(task.ls, task.lsCalculation || "N/A"));
            row.appendChild(createCell(task.lf, task.lfCalculation || "N/A"));
            const displaySlack = isNaN(task.slack)
              ? "N/A"
              : Math.round(task.slack * 1000) / 1000;
            row.appendChild(
              createCriticalCell(
                displaySlack,
                task.slackCalculation || "N/A",
                task.isCritical
              )
            );
            row.appendChild(
              createCriticalCell(
                task.isCritical ? "C√≥" : "Kh√¥ng",
                "",
                task.isCritical
              )
            ); // No tooltip for critical path column
          });
        resultsTableContainer.appendChild(table);
      }

      // --- Initial Setup ---
      clearError(); // Hide error message initially
      loadSampleData(sampleData1); // Load sample data 1 by default
      // initializeTippy(); // Initialize Tippy on initial load if needed, currently called after calculation
    </script>
  </body>
</html>
