<!DOCTYPE html>
<html lang="vi">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Tr√¨nh t·∫°o s∆° ƒë·ªì PERT</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
      /* Ki·ªÉu d√°ng b·ªï sung */
      body {
        font-family: "Inter", sans-serif;
        user-select: none;
        -webkit-user-select: none;
        -moz-user-select: none;
        -ms-user-select: none;
      }
      input::placeholder {
        text-align: center;
      }
      .action-button {
        @apply px-2 py-1 text-xs bg-gray-200 hover:bg-gray-300 rounded transition-colors duration-150;
      }
      .load-button {
        @apply px-3 py-1 text-xs bg-indigo-100 hover:bg-indigo-200 text-indigo-700 rounded transition-colors duration-150 mr-2;
      }
      #pertChart svg {
        width: 100%;
        height: auto;
        min-height: 500px;
        border: 1px solid #ccc;
        background-color: #f9f9f9;
        border-radius: 8px;
        cursor: grab;
      }
      #pertChart svg.grabbing {
        cursor: grabbing;
      }
      /* Node styles */
      .node {
        cursor: grab;
      }
      .node.dragging {
        cursor: grabbing;
      }
      .node circle {
        stroke: #333;
        stroke-width: 1.5;
        fill: #fff;
        filter: drop-shadow(2px 2px 2px rgba(0, 0, 0, 0.1));
      }
      .node line.divider {
        stroke: #aaa;
        stroke-width: 1;
      }
      /* Node text styles */
      /* INCREASED FONT SIZE HERE */
      .node text {
        font-size: 10px;
        font-weight: bold;
        text-anchor: middle;
        dominant-baseline: central; /* Changed baseline */
        pointer-events: none;
      }
      .node text.node-id {
        fill: #555;
      }
      .node text.es-text {
        fill: red;
      }
      .node text.lf-text {
        fill: blue;
      }
      .node text.slack-text {
        fill: purple;
      }
      /* Edge styles */
      .edge path {
        stroke: #666;
        stroke-width: 1.5;
        fill: none;
      }
      /* Edge text background */
      .edge text {
        font-size: 10px;
        text-anchor: middle;
        fill: #333;
        pointer-events: none;
        paint-order: stroke; /* Ensure stroke is drawn behind fill */
        stroke: #f9f9f9; /* Match background color */
        stroke-width: 3px; /* Adjust thickness for desired padding effect */
        stroke-linejoin: round;
      }
      /* Critical path styles */
      .edge.critical path {
        stroke: orange;
        stroke-width: 2.5;
      }
      .edge.critical text {
        fill: orange;
        font-weight: bold;
        stroke: #f9f9f9;
      } /* Keep background for critical text */
      .node.critical circle {
        stroke: orange;
        stroke-width: 2.5;
      }
      .node.critical line.divider {
        stroke: orange;
      }
      /* Markers */
      marker#arrowhead {
        fill: #666;
      }
      marker#arrowhead-critical {
        fill: orange;
      }
      /* Hide error message div initially */
      #errorMessage:empty {
        display: none;
      }
    </style>
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link
      href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;700&display=swap"
      rel="stylesheet"
    />
  </head>
  <body class="bg-gray-100 p-4 md:p-8">
    <div class="container mx-auto max-w-6xl bg-white p-6 rounded-lg shadow-lg">
      <h1 class="text-2xl md:text-3xl font-bold text-center text-gray-800 mb-6">
        Tr√¨nh t·∫°o s∆° ƒë·ªì PERT (Chuy·ªÉn ƒë·ªïi t·ª´ R)
      </h1>

      <div class="mb-6">
        <h2 class="text-xl font-semibold mb-3 text-gray-700">
          Nh·∫≠p th√¥ng tin c√¥ng vi·ªác
        </h2>
        <div class="mb-3">
          <button id="loadData1Btn" class="load-button">
            T·∫£i D·ªØ li·ªáu M·∫´u 1 (CPM)
          </button>
          <button id="loadData2Btn" class="load-button">
            T·∫£i D·ªØ li·ªáu M·∫´u 2 (CPM)
          </button>
        </div>
        <div class="overflow-x-auto">
          <table
            id="taskTable"
            class="w-full border-collapse border border-gray-300 text-sm md:text-base"
          >
            <thead>
              <tr class="bg-gray-200">
                <th class="border border-gray-300 p-2 w-1/12"></th>
                <th class="border border-gray-300 p-2 w-2/12">
                  C√¥ng vi·ªác (ID)
                </th>
                <th class="border border-gray-300 p-2 w-2/12">Th·ªùi gian TH</th>
                <th class="border border-gray-300 p-2 w-6/12">
                  C√¥ng vi·ªác tr∆∞·ªõc (vd: X1,X2)
                </th>
                <th class="border border-gray-300 p-2 w-1/12"></th>
              </tr>
            </thead>
            <tbody></tbody>
          </table>
        </div>
        <button
          id="addRowBtn"
          class="mt-3 mr-2 px-4 py-2 bg-blue-500 text-white rounded hover:bg-blue-600 transition-colors duration-150"
        >
          ‚ûï Th√™m c√¥ng vi·ªác
        </button>
        <button
          id="calculateBtn"
          class="mt-3 px-4 py-2 bg-green-500 text-white rounded hover:bg-green-600 transition-colors duration-150"
        >
          üìä T√≠nh to√°n & V·∫Ω s∆° ƒë·ªì
        </button>
        <div
          id="errorMessage"
          class="mt-4 text-red-600 font-semibold hidden"
        ></div>
      </div>

      <div class="mb-6">
        <h2 class="text-xl font-semibold mb-3 text-gray-700">
          S∆° ƒë·ªì PERT/CPM (K√©o th·∫£ c√°c n√∫t ƒë·ªÉ ƒëi·ªÅu ch·ªânh)
        </h2>
        <div
          id="pertChart"
          class="bg-gray-50 p-4 rounded border border-gray-300 min-h-[500px] flex items-center justify-center overflow-hidden"
        >
          <span class="text-gray-500"
            >S∆° ƒë·ªì s·∫Ω ƒë∆∞·ª£c hi·ªÉn th·ªã ·ªü ƒë√¢y sau khi t√≠nh to√°n.</span
          >
        </div>
        <div class="mt-4 text-sm text-gray-600">
          <p>
            <span class="font-bold text-red-600">ES (G√≥c tr√°i):</span> Th·ªùi gian
            s·ªõm nh·∫•t s·ª± ki·ªán c√≥ th·ªÉ x·∫£y ra.
          </p>
          <p>
            <span class="font-bold text-blue-600">LF (G√≥c ph·∫£i):</span> Th·ªùi
            gian mu·ªôn nh·∫•t s·ª± ki·ªán ph·∫£i x·∫£y ra.
          </p>
          <p>
            <span class="font-bold text-purple-600">Slack (G√≥c d∆∞·ªõi):</span>
            Th·ªùi gian d·ª± tr·ªØ c·ªßa s·ª± ki·ªán (LF - ES).
          </p>
          <p>
            <span class="font-bold text-gray-700">ID (G√≥c tr√™n):</span> M√£ ƒë·ªãnh
            danh c·ªßa s·ª± ki·ªán.
          </p>
          <p>
            <span class="font-bold text-orange-600">ƒê∆∞·ªùng gƒÉng:</span> C√°c c√¥ng
            vi·ªác v√† s·ª± ki·ªán c√≥ Slack = 0.
          </p>
        </div>
      </div>

      <div class="mb-6">
        <h2 class="text-xl font-semibold mb-3 text-gray-700">
          K·∫øt qu·∫£ t√≠nh to√°n chi ti·∫øt (CPM)
        </h2>
        <div id="resultsTableContainer" class="overflow-x-auto">
          <span class="text-gray-500">K·∫øt qu·∫£ chi ti·∫øt s·∫Ω hi·ªÉn th·ªã ·ªü ƒë√¢y.</span>
        </div>
      </div>
    </div>

    <script>
      // --- DOM Elements ---
      const taskTableBody = document.querySelector("#taskTable tbody");
      const addRowBtn = document.getElementById("addRowBtn");
      const calculateBtn = document.getElementById("calculateBtn");
      const pertChartContainer = document.getElementById("pertChart");
      const resultsTableContainer = document.getElementById(
        "resultsTableContainer"
      );
      const errorMessageDiv = document.getElementById("errorMessage");
      const loadData1Btn = document.getElementById("loadData1Btn");
      const loadData2Btn = document.getElementById("loadData2Btn");

      // --- Constants ---
      const SVG_NS = "http://www.w3.org/2000/svg";
      const NODE_RADIUS = 30;
      const H_SPACING = 150;
      const V_SPACING = 100;
      const PADDING = 50;

      // --- Sample Data (CPM format) ---
      const sampleData1 = [
        { id: "X1", duration: 3, dependencies: "" },
        { id: "X2", duration: 3, dependencies: "" },
        { id: "X3", duration: 5, dependencies: "" },
        { id: "X4", duration: 3, dependencies: "X3" },
        { id: "X5", duration: 4, dependencies: "X1" },
        { id: "X6", duration: 5, dependencies: "X1" },
        { id: "X7", duration: 3, dependencies: "X2,X4" },
        { id: "X8", duration: 4, dependencies: "X6" },
        { id: "X9", duration: 4, dependencies: "X5,X7" },
        { id: "X10", duration: 5, dependencies: "X8,X9" },
        { id: "X11", duration: 4, dependencies: "X10" },
      ];
      const sampleData2 = [
        { id: "X1", duration: 3, dependencies: "" },
        { id: "X2", duration: 3, dependencies: "" },
        { id: "X3", duration: 4, dependencies: "" },
        { id: "X4", duration: 3, dependencies: "X2" },
        { id: "X5", duration: 4, dependencies: "X1" },
        { id: "X6", duration: 5, dependencies: "X1" },
        { id: "X7", duration: 3, dependencies: "X4" },
        { id: "X8", duration: 4, dependencies: "X6" },
        { id: "X9", duration: 5, dependencies: "X3,X7" },
        { id: "X10", duration: 5, dependencies: "X5,X8,X9" },
      ];

      // --- Global State for Dragging ---
      let isDragging = false;
      let selectedNodeElement = null;
      let offset = { x: 0, y: 0 };
      let svgElement = null;
      let nodesMapRef = null;
      let edgesRef = null;

      // --- Event Listeners ---
      addRowBtn.addEventListener("click", addRow);
      calculateBtn.addEventListener("click", handleCalculation);
      taskTableBody.addEventListener("click", handleTableActions);
      loadData1Btn.addEventListener("click", () => loadSampleData(sampleData1));
      loadData2Btn.addEventListener("click", () => loadSampleData(sampleData2));

      // --- Functions ---

      // --- Data Loading ---
      function loadSampleData(data) {
        taskTableBody.innerHTML = ""; // Clear existing rows
        data.forEach((task) => {
          const newRow = createTableRow();
          newRow.querySelector(".task-id").value = task.id;
          newRow.querySelector(".duration").value = task.duration;
          newRow.querySelector(".dependencies").value = task.dependencies;
          taskTableBody.appendChild(newRow);
        });
        pertChartContainer.innerHTML =
          '<span class="text-gray-500">S∆° ƒë·ªì s·∫Ω ƒë∆∞·ª£c hi·ªÉn th·ªã ·ªü ƒë√¢y sau khi t√≠nh to√°n.</span>';
        resultsTableContainer.innerHTML =
          '<span class="text-gray-500">K·∫øt qu·∫£ chi ti·∫øt s·∫Ω hi·ªÉn th·ªã ·ªü ƒë√¢y.</span>';
        clearError();
        removeDragListeners();
      }

      // (Helper functions: handleTableActions, createTableRow, addRow, removeRow, insertRowAbove, displayError, clearError - No changes)
      function handleTableActions(event) {
        if (event.target.classList.contains("remove-row")) {
          removeRow(event.target);
        } else if (event.target.classList.contains("insert-row")) {
          insertRowAbove(event.target);
        }
      }
      function createTableRow() {
        const newRow = document.createElement("tr");
        newRow.innerHTML = ` <td class="border border-gray-300 p-1 text-center"><button class="action-button insert-row" title="Ch√®n d√≤ng v√†o tr√™n">‚¨ÜÔ∏è</button></td> <td class="border border-gray-300 p-1"><input type="text" class="w-full p-1 border rounded text-center task-id" placeholder="T√™n CV"></td> <td class="border border-gray-300 p-1"><input type="number" min="0" class="w-full p-1 border rounded text-center duration" placeholder="TG"></td> <td class="border border-gray-300 p-1"><input type="text" class="w-full p-1 border rounded text-center dependencies" placeholder="CV tr∆∞·ªõc"></td> <td class="border border-gray-300 p-1 text-center"><button class="action-button remove-row" title="X√≥a d√≤ng">üóëÔ∏è</button></td> `;
        return newRow;
      }
      function addRow() {
        const newRow = createTableRow();
        taskTableBody.appendChild(newRow);
      }
      function removeRow(button) {
        const row = button.closest("tr");
        if (taskTableBody.rows.length > 0) {
          row.remove();
        } else {
          displayError("Kh√¥ng c√≤n c√¥ng vi·ªác n√†o ƒë·ªÉ x√≥a.");
        }
      } // Allow deleting last row
      function insertRowAbove(button) {
        const currentRow = button.closest("tr");
        const newRow = createTableRow();
        taskTableBody.insertBefore(newRow, currentRow);
      }
      function displayError(message) {
        errorMessageDiv.textContent = message;
        errorMessageDiv.classList.remove("hidden");
      }
      function clearError() {
        errorMessageDiv.textContent = "";
        errorMessageDiv.classList.add("hidden");
      }

      // --- Main Calculation Handler ---
      function handleCalculation() {
        clearError();
        pertChartContainer.innerHTML =
          '<span class="text-gray-500">ƒêang t√≠nh to√°n v√† v·∫Ω s∆° ƒë·ªì...</span>';
        resultsTableContainer.innerHTML =
          '<span class="text-gray-500">ƒêang t√≠nh to√°n k·∫øt qu·∫£...</span>';
        removeDragListeners();

        try {
          const tasks = parseInputData();
          if (!tasks) return;
          if (tasks.length === 0) {
            // Handle empty input table
            displayError("Vui l√≤ng nh·∫≠p √≠t nh·∫•t m·ªôt c√¥ng vi·ªác.");
            pertChartContainer.innerHTML =
              '<span class="text-gray-500">Ch∆∞a c√≥ d·ªØ li·ªáu ƒë·ªÉ v·∫Ω s∆° ƒë·ªì.</span>';
            resultsTableContainer.innerHTML =
              '<span class="text-gray-500">Ch∆∞a c√≥ d·ªØ li·ªáu ƒë·ªÉ t√≠nh to√°n.</span>';
            return;
          }

          // Use the General buildGraph function
          const { nodes, edges, startNodeId, endNodeId } = buildGraph(tasks);
          if (!nodes || !edges) return; // Stop if graph building failed

          // Perform standard PERT/CPM calculation
          calculatePert(nodes, edges, startNodeId, endNodeId);

          nodesMapRef = nodes; // Store references for dragging
          edgesRef = edges;

          drawPertChart(nodes, edges, startNodeId, endNodeId);
          displayResultsTable(tasks, nodes); // Display calculated results
        } catch (error) {
          console.error("L·ªói trong qu√° tr√¨nh t√≠nh to√°n PERT/CPM:", error);
          displayError(
            `ƒê√£ x·∫£y ra l·ªói: ${error.message}. Vui l√≤ng ki·ªÉm tra l·∫°i d·ªØ li·ªáu nh·∫≠p ho·∫∑c c·∫•u tr√∫c ph·ª• thu·ªôc.`
          );
          pertChartContainer.innerHTML =
            '<span class="text-red-500">Kh√¥ng th·ªÉ t·∫°o s∆° ƒë·ªì do l·ªói.</span>';
          resultsTableContainer.innerHTML =
            '<span class="text-red-500">Kh√¥ng th·ªÉ hi·ªÉn th·ªã k·∫øt qu·∫£ do l·ªói.</span>';
        }
      }

      // --- Parse Input Data ---
      function parseInputData() {
        const tasks = [];
        const taskIds = new Set();
        const rows = taskTableBody.querySelectorAll("tr");
        let hasError = false;
        if (rows.length === 0) return []; // Return empty array if no rows

        rows.forEach((row, index) => {
          const idInput = row.querySelector(".task-id");
          const durationInput = row.querySelector(".duration");
          const dependenciesInput = row.querySelector(".dependencies");
          if (!idInput || !durationInput || !dependenciesInput) {
            console.error(`Missing input elements in row ${index + 1}`);
            hasError = true;
            return;
          } // Skip row on error
          const id = idInput.value.trim().toUpperCase();
          const durationStr = durationInput.value;
          const dependenciesStr = dependenciesInput.value.trim().toUpperCase();

          if (!id) {
            displayError(
              `L·ªói ·ªü d√≤ng ${index + 1}: T√™n c√¥ng vi·ªác (ID) kh√¥ng ƒë∆∞·ª£c ƒë·ªÉ tr·ªëng.`
            );
            idInput.focus();
            hasError = true;
            return;
          }
          if (taskIds.has(id)) {
            displayError(
              `L·ªói ·ªü d√≤ng ${
                index + 1
              }: T√™n c√¥ng vi·ªác (ID) "${id}" b·ªã tr√πng l·∫∑p.`
            );
            idInput.focus();
            hasError = true;
            return;
          }
          const duration = parseFloat(durationStr); // Use parseFloat to allow decimal durations
          if (isNaN(duration) || duration < 0) {
            displayError(
              `L·ªói ·ªü d√≤ng ${
                index + 1
              }: Th·ªùi gian th·ª±c hi·ªán c·ªßa c√¥ng vi·ªác "${id}" kh√¥ng h·ª£p l·ªá (ph·∫£i l√† s·ªë kh√¥ng √¢m).`
            );
            durationInput.focus();
            hasError = true;
            return;
          }
          taskIds.add(id);
          const dependencies =
            dependenciesStr === "" ||
            dependenciesStr.toLowerCase() === "ngay t·ª´ ƒë·∫ßu" ||
            dependenciesStr === "-"
              ? []
              : dependenciesStr
                  .split(",")
                  .map((dep) => dep.trim().toUpperCase())
                  .filter((dep) => dep !== "");
          tasks.push({
            id,
            duration,
            dependencies,
            es: 0,
            ef: 0,
            ls: 0,
            lf: 0,
            slack: 0,
            isCritical: false,
            startNodeId: null,
            endNodeId: null,
          });
        });

        if (!hasError) {
          // Perform dependency check only if no previous errors
          tasks.forEach((task, index) => {
            task.dependencies.forEach((depId) => {
              if (!taskIds.has(depId)) {
                const row = taskTableBody.querySelectorAll("tr")[index];
                displayError(
                  `L·ªói ·ªü d√≤ng ${index + 1}: C√¥ng vi·ªác "${
                    task.id
                  }" ph·ª• thu·ªôc v√†o c√¥ng vi·ªác kh√¥ng t·ªìn t·∫°i "${depId}".`
                );
                if (row) row.querySelector(".dependencies")?.focus();
                hasError = true;
              }
            });
          });
        }
        return hasError ? null : tasks; // Return null if any error occurred
      }

      // --- General Graph Building Logic (Simplified AoA) ---
      function buildGraph(tasks) {
        const nodes = new Map();
        const edges = [];
        const taskMap = new Map(tasks.map((task) => [task.id, task]));
        let nextNodeId = 0;

        function getNode(id) {
          if (!nodes.has(id)) {
            nodes.set(id, {
              id: id,
              es: 0,
              lf: Infinity,
              x: 0,
              y: 0,
              incomingEdges: [],
              outgoingEdges: [],
              layer: -1,
              gElement: null,
            });
          }
          return nodes.get(id);
        }

        const startNode = getNode(nextNodeId++); // Global start node (ID 0)
        const taskEndNodes = new Map(); // Map<taskId, nodeId>
        const mergeNodes = new Map(); // Map<stringified_sorted_dependency_task_ids, nodeId>

        // --- Pass 1: Determine potential start nodes and necessary merge points ---
        tasks.forEach((task) => {
          if (task.dependencies.length === 0) {
            task.startNodeId = startNode.id;
          } else {
            const depKey = JSON.stringify([...task.dependencies].sort());
            if (mergeNodes.has(depKey)) {
              task.startNodeId = mergeNodes.get(depKey);
            } else {
              // Check if all dependencies ALREADY have a COMMON known end node
              let commonEndNodeId = null;
              let firstDepEndNodeId = null;
              let allDepsHaveEndNode = true;
              for (const depId of task.dependencies) {
                const knownEndNode = taskEndNodes.get(depId);
                if (knownEndNode === undefined) {
                  // Dependency end node not yet determined
                  allDepsHaveEndNode = false;
                  break;
                }
                if (firstDepEndNodeId === null) {
                  firstDepEndNodeId = knownEndNode;
                  commonEndNodeId = knownEndNode;
                } else if (knownEndNode !== commonEndNodeId) {
                  commonEndNodeId = -1; // Indicate different end nodes
                  break;
                }
              }

              if (
                allDepsHaveEndNode &&
                commonEndNodeId !== -1 &&
                commonEndNodeId !== null
              ) {
                // All dependencies already end at the same known node, reuse it
                task.startNodeId = commonEndNodeId;
                mergeNodes.set(depKey, commonEndNodeId); // Cache this merge point
              } else {
                // Create a new node for this task to start from
                const newNode = getNode(nextNodeId++);
                task.startNodeId = newNode.id;
                mergeNodes.set(depKey, newNode.id);
                // Try to assign this new node as the end node for dependencies
                task.dependencies.forEach((depId) => {
                  if (!taskEndNodes.has(depId)) {
                    taskEndNodes.set(depId, newNode.id);
                  } else if (taskEndNodes.get(depId) !== newNode.id) {
                    // Conflict: Dependency already ends elsewhere. Needs dummy in full AoA.
                    console.warn(
                      `Task ${task.id} starts at new node ${
                        newNode.id
                      }, but dependency ${depId} already ends at ${taskEndNodes.get(
                        depId
                      )}. Dummy task might be needed.`
                    );
                    // Simple approach: Force dependency end here for this path (might be inaccurate)
                    taskEndNodes.set(depId, newNode.id);
                  }
                });
              }
            }
          }
        });

        // --- Pass 2: Assign final end nodes and create edges ---
        const tasksWithSuccessors = new Set();
        tasks.forEach((task) =>
          task.dependencies.forEach((depId) => tasksWithSuccessors.add(depId))
        );

        tasks.forEach((task) => {
          if (!taskEndNodes.has(task.id)) {
            // If end node wasn't set by a successor
            if (!tasksWithSuccessors.has(task.id)) {
              // Task has no successors, create a unique potential end node for now
              task.endNodeId = getNode(nextNodeId++).id;
            } else {
              // Task has successors, but they didn't define a common start point for it.
              // Create a new intermediate node.
              task.endNodeId = getNode(nextNodeId++).id;
              taskEndNodes.set(task.id, task.endNodeId); // Make this available for later tasks
            }
          } else {
            task.endNodeId = taskEndNodes.get(task.id); // Use the already assigned end node
          }

          // Finalize edge creation
          const startN = getNode(task.startNodeId);
          const endN = getNode(task.endNodeId);
          if (startN && endN) {
            startN.outgoingEdges.push(task);
            endN.incomingEdges.push(task);
            edges.push(task);
          } else {
            throw new Error(`L·ªói t·∫°o ƒë·ªì th·ªã cho c√¥ng vi·ªác ${task.id}.`);
          }
        });

        // --- Final End Node Processing ---
        let finalEndNode;
        const actualEndNodes = Array.from(nodes.values()).filter(
          (n) =>
            n.id !== startNode.id &&
            n.outgoingEdges.filter((e) => !e.isDummy).length === 0
        ); // Exclude dummy edges when checking

        if (actualEndNodes.length === 1) {
          finalEndNode = actualEndNodes[0];
        } else if (actualEndNodes.length > 1) {
          finalEndNode = getNode(nextNodeId++); // Create a single final node
          actualEndNodes.forEach((node) => {
            const dummyTask = {
              id: `dummy_end_${node.id}`,
              duration: 0,
              dependencies: [],
              startNodeId: node.id,
              endNodeId: finalEndNode.id,
              es: 0,
              ef: 0,
              ls: 0,
              lf: 0,
              slack: 0,
              isCritical: false,
              isDummy: true,
              gElement: null,
              pathElement: null,
              textElement: null,
              textBgElement: null,
            };
            node.outgoingEdges.push(dummyTask);
            finalEndNode.incomingEdges.push(dummyTask);
            edges.push(dummyTask);
          });
        } else if (nodes.size > 1) {
          // Only if there are nodes besides start
          console.warn(
            "Kh√¥ng t√¨m th·∫•y n√∫t k·∫øt th√∫c r√µ r√†ng. C·∫ßn ki·ªÉm tra l·∫°i logic ho·∫∑c d·ªØ li·ªáu."
          );
          // Fallback: Use the node with the highest ID as a tentative end node.
          // This is less reliable than using max ES but avoids running calculatePert prematurely.
          const maxId = Math.max(...Array.from(nodes.keys()));
          finalEndNode = nodes.get(maxId) || startNode; // Default to startNode if maxId node doesn't exist
          if (finalEndNode === startNode) {
            throw new Error("Kh√¥ng th·ªÉ x√°c ƒë·ªãnh n√∫t k·∫øt th√∫c.");
          }
          console.warn(
            "S·ª≠ d·ª•ng n√∫t c√≥ ID cao nh·∫•t l√†m n√∫t k·∫øt th√∫c t·∫°m th·ªùi:",
            finalEndNode.id
          );
        } else {
          finalEndNode = startNode; // Only start node exists
        }

        // Cycle detection
        const visited = new Set();
        const recursionStack = new Set();
        function detectCycleUtil(nodeId) {
          const node = nodes.get(nodeId);
          if (!node) return false;
          visited.add(nodeId);
          recursionStack.add(nodeId);
          for (const edge of node.outgoingEdges) {
            const neighborNodeId = edge.endNodeId;
            if (!visited.has(neighborNodeId)) {
              if (detectCycleUtil(neighborNodeId)) return true;
            } else if (recursionStack.has(neighborNodeId)) {
              return true;
            }
          }
          recursionStack.delete(nodeId);
          return false;
        }
        if (nodes.size > 0 && detectCycleUtil(startNode.id)) {
          throw new Error("ƒê·ªì th·ªã c√¥ng vi·ªác ch·ª©a v√≤ng l·∫∑p.");
        }

        return {
          nodes,
          edges,
          startNodeId: startNode.id,
          endNodeId: finalEndNode.id,
        };
      }

      // --- Calculate PERT (Standard calculation) ---
      function calculatePert(nodes, edges, startNodeId, endNodeId) {
        console.log("Running standard PERT calculation...");
        const nodeList = Array.from(nodes.values());

        nodeList.forEach((node) => (node.es = 0)); // Initialize ES

        // Forward Pass
        const inDegree = new Map();
        nodeList.forEach((node) =>
          inDegree.set(node.id, node.incomingEdges.length)
        );
        const queue = nodeList.filter((node) => inDegree.get(node.id) === 0);
        const topologicalOrder = [];
        let processedEdges = 0; // Counter for cycle detection during sort

        while (queue.length > 0) {
          const uNode = queue.shift();
          topologicalOrder.push(uNode);

          uNode.outgoingEdges.forEach((edge) => {
            processedEdges++;
            const vNode = nodes.get(edge.endNodeId);
            if (vNode) {
              const potential_es = uNode.es + edge.duration;
              vNode.es = Math.max(vNode.es, potential_es);
              edge.es = uNode.es;
              edge.ef = edge.es + edge.duration;
              inDegree.set(vNode.id, inDegree.get(vNode.id) - 1);
              if (inDegree.get(vNode.id) === 0) {
                queue.push(vNode);
              }
            }
          });
        }

        if (topologicalOrder.length !== nodes.size) {
          console.error(
            "Topological sort failed. Graph likely contains a cycle."
          );
          throw new Error(
            "ƒê·ªì th·ªã ch·ª©a v√≤ng l·∫∑p, kh√¥ng th·ªÉ th·ª±c hi·ªán t√≠nh to√°n PERT."
          );
        }

        // Determine project duration
        const endNode = nodes.get(endNodeId);
        let projectDuration = 0;
        if (endNode) {
          projectDuration = endNode.es;
        } else {
          projectDuration = Math.max(0, ...nodeList.map((n) => n.es));
          console.warn(
            `End node ${endNodeId} not found/reachable. Using max ES ${projectDuration}.`
          );
        }

        // Initialize LF and Backward Pass
        nodeList.forEach((node) => (node.lf = projectDuration));
        if (endNode) {
          endNode.lf = projectDuration;
        }

        for (let i = topologicalOrder.length - 1; i >= 0; i--) {
          const uNode = topologicalOrder[i];
          uNode.incomingEdges.forEach((edge) => {
            const vNode = nodes.get(edge.startNodeId);
            if (vNode) {
              const potential_lf = uNode.lf - edge.duration;
              vNode.lf = Math.min(vNode.lf, potential_lf);
              edge.lf = uNode.lf;
              edge.ls = edge.lf - edge.duration;
            }
          });
        }

        // Calculate Slack and Critical Path
        const tolerance = 0.001;
        edges.forEach((edge) => {
          const startNode = nodes.get(edge.startNodeId);
          const endNode = nodes.get(edge.endNodeId);
          if (startNode && endNode) {
            edge.slack = edge.ls - edge.es;
            edge.isCritical =
              Math.abs(edge.slack) < tolerance &&
              Math.abs(startNode.lf - startNode.es) < tolerance &&
              Math.abs(endNode.lf - endNode.es) < tolerance;
            if (edge.isCritical) edge.slack = 0;
          } else {
            edge.slack = NaN;
            edge.isCritical = false;
          }
        });
        nodeList.forEach((node) => {
          node.slack = node.lf - node.es;
          node.isCritical = Math.abs(node.slack) < tolerance;
          if (node.isCritical) node.slack = 0;
        });
        console.log("Standard PERT calculation complete.");
      }

      // --- Draw PERT Chart ---
      function drawPertChart(nodesMap, edges, startNodeId, endNodeId) {
        pertChartContainer.innerHTML = ""; // Clear previous chart
        svgElement = document.createElementNS(SVG_NS, "svg");
        const defs = document.createElementNS(SVG_NS, "defs");
        const marker = createMarker("arrowhead", "#666");
        const markerCritical = createMarker("arrowhead-critical", "orange");
        defs.appendChild(marker);
        defs.appendChild(markerCritical);
        svgElement.appendChild(defs);

        const nodes = Array.from(nodesMap.values());

        // --- Layout Nodes (Simple Layered Approach) ---
        const layers = new Map();
        const nodeLayer = new Map();
        const sortedNodes = [...nodes].sort(
          (a, b) => a.es - b.es || a.id - b.id
        ); // Sort by ES, then ID
        let maxLayer = 0;
        const esToLayer = new Map();
        let currentLayerIndex = 0;

        // Assign layers based on ES values
        sortedNodes.forEach((node) => {
          const esRounded = Math.round(node.es * 100) / 100; // Group by similar ES
          if (!esToLayer.has(esRounded)) {
            esToLayer.set(esRounded, currentLayerIndex++);
          }
          node.layer = esToLayer.get(esRounded);
          maxLayer = Math.max(maxLayer, node.layer);
          if (!layers.has(node.layer)) layers.set(node.layer, []);
          layers.get(node.layer).push(node.id);
          nodeLayer.set(node.id, node.layer);
        });

        // Calculate SVG dimensions based on layout
        let maxNodesInLayer = 0;
        layers.forEach(
          (layerNodes) =>
            (maxNodesInLayer = Math.max(maxNodesInLayer, layerNodes.length))
        );
        const layerContentHeight =
          maxNodesInLayer > 1 ? (maxNodesInLayer - 1) * V_SPACING : 0;
        const totalHeight =
          PADDING * 2 + Math.max(layerContentHeight, NODE_RADIUS * 2);
        const totalWidth =
          PADDING * 2 + (maxLayer > 0 ? maxLayer * H_SPACING : NODE_RADIUS * 2);
        svgElement.setAttribute(
          "viewBox",
          `0 0 ${Math.max(totalWidth, 600)} ${Math.max(totalHeight, 500)}`
        );
        svgElement.setAttribute("preserveAspectRatio", "xMidYMid meet");

        // Calculate initial X, Y positions
        layers.forEach((nodeIdsInLayer, layerIndex) => {
          const layerNodeCount = nodeIdsInLayer.length;
          const layerHeight =
            layerNodeCount > 1 ? (layerNodeCount - 1) * V_SPACING : 0;
          const remainingHeight = totalHeight - PADDING * 2;
          const startY =
            PADDING + Math.max(0, (remainingHeight - layerHeight) / 2); // Center vertically
          const sortedNodeIds = nodeIdsInLayer.sort((a, b) => a - b); // Sort by ID for consistent vertical order
          sortedNodeIds.forEach((nodeId, nodeIndex) => {
            const node = nodesMap.get(nodeId);
            node.x = PADDING + node.layer * H_SPACING; // Use assigned layer for X
            node.y = startY + nodeIndex * V_SPACING;
          });
        });

        // --- Draw Edges & Nodes ---
        const edgeGroup = document.createElementNS(SVG_NS, "g");
        edgeGroup.setAttribute("class", "edges");
        edges.forEach((edge) => drawEdge(edge, edgeGroup, nodesMap)); // Draw edges first
        svgElement.appendChild(edgeGroup);
        const nodeGroup = document.createElementNS(SVG_NS, "g");
        nodeGroup.setAttribute("class", "nodes");
        nodes.forEach((node) => {
          drawNode(node, nodeGroup);
          node.gElement = nodeGroup.lastChild;
        }); // Draw nodes on top
        svgElement.appendChild(nodeGroup);
        pertChartContainer.appendChild(svgElement);
        addDragListeners(); // Enable dragging after elements are in the DOM
      }

      // --- Helper to create marker (No changes) ---
      function createMarker(id, color) {
        const marker = document.createElementNS(SVG_NS, "marker");
        marker.setAttribute("id", id);
        marker.setAttribute("markerWidth", "10");
        marker.setAttribute("markerHeight", "7");
        marker.setAttribute("refX", "9");
        marker.setAttribute("refY", "3.5");
        marker.setAttribute("orient", "auto");
        const polygon = document.createElementNS(SVG_NS, "polygon");
        polygon.setAttribute("points", "0 0, 10 3.5, 0 7");
        polygon.setAttribute("fill", color);
        marker.appendChild(polygon);
        return marker;
      }

      // --- Helper to draw node (Displays calculated values) ---
      function drawNode(node, parentGroup) {
        const nodeElement = document.createElementNS(SVG_NS, "g");
        nodeElement.setAttribute(
          "class",
          `node ${node.isCritical ? "critical" : ""}`
        );
        nodeElement.setAttribute(
          "transform",
          `translate(${node.x}, ${node.y})`
        );
        nodeElement.setAttribute("data-node-id", node.id);

        const circle = document.createElementNS(SVG_NS, "circle");
        circle.setAttribute("r", NODE_RADIUS);
        nodeElement.appendChild(circle);

        // --- MODIFICATION: Draw X instead of + ---
        const r = NODE_RADIUS * 0.95; // Radius for lines
        const lineOffset = r / Math.sqrt(2); // Offset for X endpoints

        const line1 = document.createElementNS(SVG_NS, "line"); // Top-left to Bottom-right
        line1.setAttribute("class", "divider");
        line1.setAttribute("x1", -lineOffset);
        line1.setAttribute("y1", -lineOffset);
        line1.setAttribute("x2", lineOffset);
        line1.setAttribute("y2", lineOffset);
        nodeElement.appendChild(line1);

        const line2 = document.createElementNS(SVG_NS, "line"); // Top-right to Bottom-left
        line2.setAttribute("class", "divider");
        line2.setAttribute("x1", lineOffset);
        line2.setAttribute("y1", -lineOffset);
        line2.setAttribute("x2", -lineOffset);
        line2.setAttribute("y2", lineOffset);
        nodeElement.appendChild(line2);
        // --- END MODIFICATION ---

        // --- MODIFICATION: Adjusted text positioning ---
        const textOffset = NODE_RADIUS * 0.5; // Slightly increased offset for better spacing with larger font

        // Order: Top: ID, Left: ES, Right: LF, Bottom: Slack
        const nodeIdText = createTextElement(
          "node-id",
          0,
          -textOffset,
          node.id
        ); // Top center
        nodeElement.appendChild(nodeIdText);
        const esText = createTextElement("es-text", -textOffset, 0, node.es); // Middle left
        nodeElement.appendChild(esText);
        const lfText = createTextElement("lf-text", textOffset, 0, node.lf); // Middle right
        nodeElement.appendChild(lfText);
        const slackText = createTextElement(
          "slack-text",
          0,
          textOffset,
          node.slack
        ); // Bottom center
        nodeElement.appendChild(slackText);
        // --- END MODIFICATION ---

        parentGroup.appendChild(nodeElement);
      }

      // --- Helper to create text element (No changes) ---
      function createTextElement(className, x, y, content) {
        const text = document.createElementNS(SVG_NS, "text");
        text.setAttribute("class", className);
        text.setAttribute("x", x);
        text.setAttribute("y", y);
        text.textContent = content;
        return text;
      }

      // --- Helper to draw/update edge (Added text background) ---
      function drawEdge(edge, parentGroup, nodesMap) {
        const startNode = nodesMap.get(edge.startNodeId);
        const endNode = nodesMap.get(edge.endNodeId);
        if (!startNode || !endNode) return;
        const { startX, startY, endX, endY, angle, midX, midY } =
          calculateEdgePoints(startNode, endNode);
        let edgeElement = edge.gElement;
        let textBgElement = edge.textBgElement;

        if (!edgeElement) {
          // Create elements if they don't exist
          edgeElement = document.createElementNS(SVG_NS, "g");
          edgeElement.setAttribute(
            "class",
            `edge ${edge.isCritical ? "critical" : ""} ${
              edge.isDummy ? "dummy" : ""
            }`
          );
          edgeElement.setAttribute("data-edge-id", edge.id);
          const path = document.createElementNS(SVG_NS, "path");
          path.setAttribute(
            "marker-end",
            `url(#${edge.isCritical ? "arrowhead-critical" : "arrowhead"})`
          );
          if (edge.isDummy) path.setAttribute("stroke-dasharray", "5,5");
          edgeElement.appendChild(path);
          edge.pathElement = path;
          if (!edge.isDummy) {
            // textBgElement = document.createElementNS(SVG_NS, 'rect'); textBgElement.setAttribute('class', 'text-bg'); edgeElement.appendChild(textBgElement); edge.textBgElement = textBgElement; // Background rect removed for stroke approach
            const text = document.createElementNS(SVG_NS, "text");
            edgeElement.appendChild(text);
            edge.textElement = text;
          }
          parentGroup.appendChild(edgeElement);
          edge.gElement = edgeElement;
        } else {
          // Update existing elements
          edgeElement.setAttribute(
            "class",
            `edge ${edge.isCritical ? "critical" : ""} ${
              edge.isDummy ? "dummy" : ""
            }`
          );
          edge.pathElement.setAttribute(
            "marker-end",
            `url(#${edge.isCritical ? "arrowhead-critical" : "arrowhead"})`
          );
        }

        edge.pathElement.setAttribute(
          "d",
          `M ${startX},${startY} L ${endX},${endY}`
        ); // Update path

        if (!edge.isDummy && edge.textElement) {
          // Update text position and content
          const textOffset = -10;
          const textX = midX + textOffset * Math.sin((angle * Math.PI) / 180);
          const textY = midY - textOffset * Math.cos((angle * Math.PI) / 180);
          edge.textElement.setAttribute("x", textX);
          edge.textElement.setAttribute("y", textY);
          edge.textElement.textContent = `${edge.id} (${edge.duration})`;
          // Background rect update removed
        }
      }

      // --- Helper to calculate edge points (No changes) ---
      function calculateEdgePoints(startNode, endNode) {
        const dx = endNode.x - startNode.x;
        const dy = endNode.y - startNode.y;
        const dist = Math.sqrt(dx * dx + dy * dy);
        let startX = startNode.x,
          startY = startNode.y,
          endX = endNode.x,
          endY = endNode.y;
        let angle = Math.atan2(dy, dx);
        if (dist > NODE_RADIUS * 2) {
          const ratio = NODE_RADIUS / dist;
          startX = startNode.x + dx * ratio;
          startY = startNode.y + dy * ratio;
          endX = endNode.x - dx * ratio;
          endY = endNode.y - dy * ratio;
        } else if (dist > 0) {
          startX = startNode.x + dx * 0.4;
          startY = startNode.y + dy * 0.4;
          endX = endNode.x - dx * 0.4;
          endY = endNode.y - dy * 0.4;
        }
        const midX = (startX + endX) / 2;
        const midY = (startY + endY) / 2;
        return {
          startX,
          startY,
          endX,
          endY,
          angle: (angle * 180) / Math.PI,
          midX,
          midY,
        };
      }

      // --- Drag and Drop Logic (No changes) ---
      function addDragListeners() {
        if (!svgElement) return;
        svgElement.addEventListener("mousedown", startDrag);
        svgElement.addEventListener("mousemove", drag);
        svgElement.addEventListener("mouseup", endDrag);
        svgElement.addEventListener("mouseleave", endDrag);
        svgElement.addEventListener("touchstart", startDrag, {
          passive: false,
        });
        svgElement.addEventListener("touchmove", drag, { passive: false });
        svgElement.addEventListener("touchend", endDrag);
        svgElement.addEventListener("touchcancel", endDrag);
      }
      function removeDragListeners() {
        if (!svgElement) return;
        svgElement.removeEventListener("mousedown", startDrag);
        svgElement.removeEventListener("mousemove", drag);
        svgElement.removeEventListener("mouseup", endDrag);
        svgElement.removeEventListener("mouseleave", endDrag);
        svgElement.removeEventListener("touchstart", startDrag);
        svgElement.removeEventListener("touchmove", drag);
        svgElement.removeEventListener("touchend", endDrag);
        svgElement.removeEventListener("touchcancel", endDrag);
      }
      function getMousePosition(evt) {
        if (!svgElement) return { x: 0, y: 0 };
        const CTM = svgElement.getScreenCTM();
        if (!CTM) return { x: 0, y: 0 };
        let clientX, clientY;
        if (evt.touches) {
          clientX = evt.touches[0].clientX;
          clientY = evt.touches[0].clientY;
        } else {
          clientX = evt.clientX;
          clientY = evt.clientY;
        }
        return { x: (clientX - CTM.e) / CTM.a, y: (clientY - CTM.f) / CTM.d };
      }
      function startDrag(evt) {
        let targetElement = evt.target;
        while (targetElement && targetElement !== svgElement) {
          if (
            targetElement.classList &&
            targetElement.classList.contains("node")
          ) {
            selectedNodeElement = targetElement;
            break;
          }
          targetElement = targetElement.parentNode;
        }
        if (selectedNodeElement) {
          evt.preventDefault();
          isDragging = true;
          selectedNodeElement.classList.add("dragging");
          svgElement.classList.add("grabbing");
          const startPos = getMousePosition(evt);
          const transform = selectedNodeElement.transform.baseVal;
          const currentTranslate =
            transform.numberOfItems > 0
              ? transform.getItem(0).matrix
              : { e: 0, f: 0 };
          offset.x = currentTranslate.e - startPos.x;
          offset.y = currentTranslate.f - startPos.y;
        }
      }
      function drag(evt) {
        if (isDragging && selectedNodeElement) {
          evt.preventDefault();
          const coord = getMousePosition(evt);
          const newX = coord.x + offset.x;
          const newY = coord.y + offset.y;
          selectedNodeElement.setAttribute(
            "transform",
            `translate(${newX}, ${newY})`
          );
          const nodeId = parseInt(
            selectedNodeElement.getAttribute("data-node-id"),
            10
          );
          const nodeData = nodesMapRef.get(nodeId);
          if (nodeData) {
            nodeData.x = newX;
            nodeData.y = newY;
            updateConnectedEdges(nodeData);
          }
        }
      }
      function endDrag(evt) {
        if (isDragging) {
          if (selectedNodeElement) {
            selectedNodeElement.classList.remove("dragging");
          }
          if (svgElement) {
            svgElement.classList.remove("grabbing");
          }
          isDragging = false;
          selectedNodeElement = null;
        }
      }
      function updateConnectedEdges(movedNode) {
        if (!edgesRef || !nodesMapRef || !svgElement) return;
        const edgeGroup = svgElement.querySelector(".edges");
        if (!edgeGroup) return;
        movedNode.outgoingEdges.forEach((edge) =>
          drawEdge(edge, edgeGroup, nodesMapRef)
        );
        movedNode.incomingEdges.forEach((edge) =>
          drawEdge(edge, edgeGroup, nodesMapRef)
        );
      }

      // --- Display Results Table (Displays calculated values) ---
      function displayResultsTable(tasks, nodesMap) {
        resultsTableContainer.innerHTML = "";
        const edgesToDisplay = edgesRef; // Use edgesRef which has calculated task times
        if (!edgesToDisplay || edgesToDisplay.length === 0) {
          resultsTableContainer.innerHTML =
            '<span class="text-gray-500">Kh√¥ng c√≥ d·ªØ li·ªáu c·∫°nh ƒë·ªÉ hi·ªÉn th·ªã k·∫øt qu·∫£ chi ti·∫øt.</span>';
          return;
        }
        const table = document.createElement("table");
        table.className =
          "w-full border-collapse border border-gray-300 text-sm md:text-base";
        const thead = table.createTHead();
        thead.innerHTML = ` <tr class="bg-gray-200"> <th class="border border-gray-300 p-2">C√¥ng vi·ªác</th> <th class="border border-gray-300 p-2">Th·ªùi gian TH</th> <th class="border border-gray-300 p-2">ES (Task)</th> <th class="border border-gray-300 p-2">EF (Task)</th> <th class="border border-gray-300 p-2">LS (Task)</th> <th class="border border-gray-300 p-2">LF (Task)</th> <th class="border border-gray-300 p-2">Slack (D·ª± tr·ªØ)</th> <th class="border border-gray-300 p-2">ƒê∆∞·ªùng gƒÉng?</th> </tr> `;
        const tbody = table.createTBody();
        edgesToDisplay
          .filter((task) => !task.isDummy)
          .forEach((task) => {
            const row = tbody.insertRow();
            row.innerHTML = ` <td class="border border-gray-300 p-2">${
              task.id
            }</td> <td class="border border-gray-300 p-2 text-center">${
              task.duration
            }</td> <td class="border border-gray-300 p-2 text-center">${
              task.es
            }</td> <td class="border border-gray-300 p-2 text-center">${
              task.ef
            }</td> <td class="border border-gray-300 p-2 text-center">${
              task.ls
            }</td> <td class="border border-gray-300 p-2 text-center">${
              task.lf
            }</td> <td class="border border-gray-300 p-2 text-center ${
              task.isCritical ? "text-orange-600 font-bold" : ""
            }">${
              task.slack
            }</td> <td class="border border-gray-300 p-2 text-center ${
              task.isCritical ? "text-orange-600 font-bold" : ""
            }">${task.isCritical ? "C√≥" : "Kh√¥ng"}</td> `;
          });
        resultsTableContainer.appendChild(table);
      }

      // --- Initial Setup ---
      clearError(); // Hide error message initially
      loadSampleData(sampleData1); // Load sample data 1 by default
    </script>
  </body>
</html>
